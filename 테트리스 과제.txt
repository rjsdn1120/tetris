과제명: 테트리스

[제공 파일]
- main.html
- main.css
- jquery-3.3.1.js

[유의사항]
제공 파일은 PC랑 1:1 대전모드 기반으로 만들어졌기에 솔플 모드로 먼저 개발을 추천.
대전모드를 고려하여 설계해도 좋음 ex) gameBoxId 변수

[요구사항]
- 테트리스 블럭 총 7가지를 테트리스 규칙에 따라 제작.

- 초기 블럭 위치 배열 제공
var blockSet = [[[0,4], [0,5], [1,4], [1,5]],	// 네모
					[[1,4], [0,3], [1,3], [1,5]],	// 니은
					[[1,4], [1,3], [1,5], [0,5]],	// 반대 니은
					[[1,4], [0,4], [1,5], [2,5]],	// 꼬부리
					[[1,5], [1,4], [0,5], [2,4]],	// 반대꼬부리
					[[1,4], [0,4], [2,4], [3,4]],	// ㅣ
					[[1,4], [1,3], [1,5], [0,4]]]	// ㅗ

- 전역 변수
var size = 40;
var Row, Col;
var currentBlockType, nextBlockType = [], currentBlockTypePC;
var gameMode = false;
var guideMode = true;
var rotateMode = true;
var rotateType = true;

var blockOrderData = [];
var blockOrderDataPC = [];

var timer, autoTimer, comTimer, comAutoTimer;
var autoPlayMode = false;

var autoDropTime = 1000;
var autoPlayTime = 1000;

var userGameBoxID = "#gamebox";
var comGameBoxID = "#gameboxPC";

 
- 맵 사이즈 : size에 따라 동적 생성 40으로 설정시 10 X 20 (제공코드 1 참고)
- 타이머 시간에 따라 1칸씩 내려오며 블럭이 바닥이나 다른 블럭에 닿는 경우 새로운 블럭 생성 (setTimeout 함수)

- 키보드 방향키로 양옆, 아래로 한칸씩 이동 가능 벽에 닿으면 이동 불가
- Z 클릭시 바로 바닥으로 내려감 (제공코드 2 참고)
- 줄이 모두 채워지면 그 줄은 사라져야함

[제공코드 1]
$("#startBtn").on("click", function(event){
	gameMode = true;
	$("label#score").text(0);
	$("#startBtn").css("visibility", "hidden");
	$(".matchResult").css("display", "none");
	$(userGameBoxID).css("opacity", "1.0");
	$(comGameBoxID).css("opacity", "1.0");
	$(userGameBoxID).focus();
	Row = Math.round($(userGameBoxID).height() / size);
	Col = Math.round($(userGameBoxID).width() / size);
	
	InitMap(userGameBoxID);
	InitMap(comGameBoxID);
	createBlockOrderData();

	currentBlock = createBlock(userGameBoxID);
	guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);

	currentBlockPC = createBlock(comGameBoxID);
	guideBlockPC = drawGuide(currentBlockPC, guideBlockPC, comGameBoxID);

	timer = setTimeout(function(){
		callbackTimer(userGameBoxID);
	}, autoDropTime);

	comTimer = setTimeout(function(){
		callbackTimer(comGameBoxID);
	}, autoDropTime);

	comAutoTimer = setTimeout(function(){
		callbackAutoTimer(comGameBoxID);
	}, autoPlayTime);

});

[제공코드 2]
$(userGameBoxID).on("keydown", function(event) {
	if(gameMode && !autoPlayMode){
		if(event.which == '37'){		// Left
			if(!isOverlayed(currentBlock, userGameBoxID)){
				moveBlock(event.which, currentBlock, userGameBoxID);
				guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);
			}
			else{
				currentBlock = createBlock(userGameBoxID);
				guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);
			}
		}
		else if(event.which == '39'){	// Right
			if(!isOverlayed(currentBlock, userGameBoxID)){
				moveBlock(event.which, currentBlock, userGameBoxID);
				guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);
			}
			else{
				currentBlock = createBlock(userGameBoxID);
				guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);
			}
		}
		else if(event.which == '40'){	// Down
			if(!isOverlayed(currentBlock, userGameBoxID)){
				moveBlock(event.which, currentBlock, userGameBoxID);
				guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);
			}
			else{
				currentBlock = createBlock(userGameBoxID);
				guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);
			}
		}
		else if(event.which == '38'){	// Up / Rotate
			rotateBlock(currentBlock, userGameBoxID);
			guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);
		}
		else if(event.which == '90'){	// Z Key
			if(!isOverlayed(currentBlock, userGameBoxID)){
				dropBlock(currentBlock, userGameBoxID);
				currentBlock = createBlock(userGameBoxID);
				guideBlock = drawGuide(currentBlock, guideBlock, userGameBoxID);
			}
		}
	}
});


[함수 설명(파라미터 제외)]
InitMap() : 맵 생성
function InitMap(gameBoxID){

	if($(gameBoxID + ":has(tr)").length == 0){
		for(var i = 0; i < Row; i++)
			$(gameBoxID).append("<tr></tr>");
		for(var j = 0; j < Col; j++)
			$(gameBoxID + " tr").append("<td></td>");
	}

	for(var i = 0; i < Row; i++){
		for(var j = 0; j < Col; j++){
			$(gameBoxID + " tr").eq(i).children().eq(j).css("backgroundColor", "rgba(0, 0, 0, 0)");
			$(gameBoxID + " tr").eq(i).children().eq(j).attr("class", "originBlock");
		}
	}	
}

createBlockOrderData() : 나올 블록 5천개 랜덤으로 생성해서 배열에 저장.
function createBlockOrderData(){
	for(var j = 0; j < 5000; j++){
		var tempData = [0, 1, 2, 3, 4, 5, 6];
		for(var i = 0; i < 20; i++){
			var val1 = Math.floor(Math.random() * 7);
			var val2 = Math.floor(Math.random() * 7);
			
			var temp = tempData[val1];
			tempData[val1] = tempData[val2];
			tempData[val2] = temp;
		}
		blockOrderData = blockOrderData.concat(tempData);
	}

	blockOrderDataPC = blockOrderData.slice();

	nextBlockType.push(blockOrderData.shift());
	nextBlockType.push(blockOrderData.shift());
}

createBlock() : 신규 블록 띄우기
fillBlock() : 블록 색칠하기
isOverlayed() : 벽이나 다른 블록과 닿았는지 확인
moveBlock() : 블록 이동
rotateBlock() : 블럭 회전, 현재 위치에서 회전 가능한지 판단 필요

[참고 코드 : 블럭 회전시 사용하는 수식]
var rotate90Mode = [[0, -1], [1, 0]]; // 시계방향
var rotate270Mode = [[0, 1], [-1, 0]]; // 반시계방향

tempBlock = multiplyMatrix(tempBlock, rotate90Mode);
function multiplyMatrix(a, b) { 
	var aNumRows = a.length, aNumCols = a[0].length,
	bNumRows = b.length, bNumCols = b[0].length,
	m = new Array(aNumRows);  // initialize array of rows
	for (var r = 0; r < aNumRows; ++r) {
		m[r] = new Array(bNumCols); // initialize the current row
		for (var c = 0; c < bNumCols; ++c) {
			m[r][c] = 0;             // initialize the current cell
			for (var i = 0; i < aNumCols; ++i) {
				m[r][c] += Math.round(a[r][i] * b[i][c]);
			}
		}
	}
	return m;
}

dropBlock() : 블럭을 맨 아래 위치로 내림
drawGuide() : 현재 블록 모양과 위치에 따른 가이드 블록 표시
eraseBlock() : 한줄 다 채워지면 줄 삭제


[Tip]
- XXX.find('tr').eq(i).find('td').eq(j) i번째 tr, j번째 td를 찾아 색칠하여 해당 블럭의 위치를 표시, 해당 칸 색상을 비교하여 블록 존재 유무 파악 가능 (기존 블럭 위치 기억할 필요 없음)